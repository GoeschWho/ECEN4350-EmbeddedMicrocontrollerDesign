C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE COMPDESIGNPROJECT
OBJECT MODULE PLACED IN .\Objects\CompDesignProject.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CompDesignProject.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\CompDe
                    -signProject.lst) OBJECT(.\Objects\CompDesignProject.obj)

line level    source

   1          /* Auth: Megan Bird
   2           * File: CompDesignProject.c
   3           * Course: CEEN-4330 – Microprocessor System Design – University of Nebraska-Lincoln
   4           * Lab: Project
   5           * Date: 3/14/2017
   6           * Desc: 8051 program with ROM, RAM, and I/O
   7           */
   8           
   9          #include <REGX55.H>
  10          #include <stdio.h>
  11          #include <absacc.h>
  12          
  13          // P1
  14          sbit P1_0 = P1^0;
  15          sbit P1_1 = P1^1;
  16          
  17          // P3
  18          sbit P3_0 = P3^0;
  19          sbit P3_1 = P3^1;
  20          sbit P3_2 = P3^2;
  21          sbit P3_3 = P3^3;
  22          sbit P3_4 = P3^4;
  23          sbit P3_5 = P3^5;
  24          sbit P3_6 = P3^6;
  25          sbit P3_7 = P3^7;
  26          
  27          // Keypad
  28          sbit kCol1  = P1^7;
  29          sbit kCol2  = P1^6;
  30          sbit kCol3  = P1^5;
  31          sbit kCol4  = P1^4;
  32          sbit kRow1  = P1^3;
  33          sbit kRow2  = P1^2;
  34          sbit kRow3  = P1^1;
  35          sbit kRow4  = P1^0;
  36          sbit cs_keypad = P3^1;          // latch
  37          sbit oe_keypad = P3^2;
  38          
  39          // Seven-Segment Display
  40          sfr sevenSegPort = 0x90;
  41          sbit cs_sevenSeg = P3^0;        // latch
  42          
  43          // LCD
  44          sbit cs_lcd = P3^3;                             // latch
  45          sbit rs_lcd = P3^4;                             // reg select
  46          sbit e_lcd  = P3^5;                             // enable
  47          // rw tied to ground to always enable read
  48          sfr lcdPort = 0x90;
  49          
  50          // ADC
  51          sbit oe_adc = P3^3;                             // latch output enable
  52          sbit wr_adc = P3^4;                             // WR line of ADC
  53          sfr adcPort = 0x90;
  54          
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 2   

  55          // RTC
  56          sbit rtc_data0 = P1^0;
  57          sbit rtc_data1 = P1^1;
  58          sbit rtc_data2 = P1^2;
  59          sbit rtc_data3 = P1^3;
  60          sbit rtc_add0 = P1^4;
  61          sbit rtc_add1 = P1^5;
  62          sbit rtc_add2 = P1^6;
  63          sbit rtc_add3 = P1^7;
  64          sfr rtcPort = 0x90;
  65          
  66          // Mission Control 1
  67          enum {ctrl_off,
  68                                  ctrl_ss_latch,
  69                                  ctrl_kp_oe,
  70                                  ctrl_kp_oelatch,
  71                                  ctrl_lcd_cmd_start,
  72                                  ctrl_lcd_cmd_finish,
  73                                  ctrl_lcd_data_start,
  74                                  ctrl_lcd_data_finish };
  75          
  76          // Mission Control 2
  77          enum {ctrl_adc_start = 1,
  78                                  ctrl_rtc_rd,
  79                                  ctrl_adc_finish,
  80                                  ctrl_rtc_cs1,
  81                                  ctrl_rtc_cs0 = 6,
  82                                  ctrl_rtc_wr };
  83          
  84          sbit dec0 = P3^3;
  85          sbit dec1 = P3^4;       // Rewired, GAL2 not in use             
  86          sbit dec2 = P3^2;       // Rewired, GAL2 not in use
  87          sbit dec3 = P3^3;
  88          sbit dec4 = P3^4;
  89          sbit dec5 = P3^5;
  90          
  91          // ======================= prototypes =========================== //
  92          
  93          typedef unsigned char byte;
  94          typedef unsigned short word;
  95          typedef enum { false, true } bool;
  96          
  97          struct keypad_data {
  98                  bool k1;
  99                  bool k2;
 100                  bool k3;
 101                  bool k4;
 102                  bool k5;
 103                  bool k6;
 104                  bool k7;
 105                  bool k8;
 106                  bool k9;
 107                  bool k0;
 108                  bool kA;
 109                  bool kB;
 110                  bool kC;
 111                  bool kD;
 112                  bool kstar;
 113                  bool kpound;
 114          };
 115          
 116          //------- high level prototyeps -------//
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 3   

 117          void mainMenu( void );
 118          void memoryMenu( void );
 119          void serialMenu( void );
 120          void dumpMenu( void );
 121          void moveMenu( void );
 122          void editMenu( void );
 123          void findMenu( void );
 124          
 125          word input4Hex( void );
 126          byte input2Hex( void );
 127          word inputHex( void );
 128          void waitForKeyRelease( void );
 129          
 130          //------- low level prototypes -------//
 131          void latchKeypad( void );
 132          struct keypad_data getKeysPressed( void );
 133          
 134          void lcdCmd( byte cmd );
 135          void lcdData( byte dat );
 136          void lcdInit( void );
 137          void lcdClear( void );
 138          void lcdChar( byte character );
 139          void lcdString( volatile char *string );
 140          void lcdLine( int line );
 141          void lcdHexWord( word hex );
 142          void lcdHexByte( byte hex );
 143          void lcdAsciiByte( byte hex );
 144          
 145          void missionControl1( int dec );
 146          void msDelay( unsigned msecs );
 147          
 148          // ======================== main ================================ //
 149          
 150          void main(void) {
 151   1              
 152   1              missionControl1( ctrl_off );
 153   1              //missionControl2( ctrl_off );
 154   1              
 155   1              lcdInit();
 156   1              //rtcInit();
 157   1      
 158   1              mainMenu();             // Enter main program
 159   1      
 160   1              while(1); // Stay off the streets
 161   1      
 162   1      } // end main()
 163          
 164          // ======================= functions ============================ //
 165          
 166          void mainMenu( void ) { 
 167   1      
 168   1              struct keypad_data keypad;
 169   1      
 170   1              while(1) {
 171   2      
 172   2                      char MenuStr1[] = "Megan Bird CEEN 4330`";
 173   2                      char MenuStr2[] = "--------------------`";
 174   2                      char MenuStr3[] = "Main Menu`";
 175   2                      char MenuStr4[] = "1: Memory  2: Serial`";
 176   2              
 177   2                      lcdClear();
 178   2                      lcdString( &MenuStr1 );
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 4   

 179   2                      lcdLine(2);
 180   2                      lcdString( &MenuStr2 );
 181   2                      lcdLine(3);
 182   2                      lcdString( &MenuStr3 );
 183   2                      lcdLine(4);
 184   2                      lcdString( &MenuStr4 );
 185   2              
 186   2                      while(1) {      
 187   3                              keypad = getKeysPressed();
 188   3                      
 189   3                              if( keypad.k1 == true ) {
 190   4                                      waitForKeyRelease();
 191   4                                      memoryMenu();
 192   4                                      break;
 193   4                              }
 194   3                              else if( keypad.k2 == true ) {
 195   4                                      waitForKeyRelease();
 196   4                                      serialMenu();
 197   4                                      break;
 198   4                              }
 199   3                      } // end option while
 200   2      
 201   2              } // end main while
 202   1      
 203   1      } // end choiceMainMenu()
 204          
 205          // -------------------------------------------------------------- //
 206          
 207          void serialMenu( void ) {
 208   1      
 209   1              struct keypad_data keypad;
 210   1              bool exit = false;
 211   1              word baud_rate = 0x0000;
 212   1              bool parity = false;
 213   1              bool stop_bits = false;
 214   1              word tx_string = 0x0000;
 215   1              int i = 0;
 216   1      
 217   1              while( exit == false ) {
 218   2      
 219   2                      char MenuStr1[] = "Serial Setup`";
 220   2                      char MenuStr2[] = "--------------------`";
 221   2      
 222   2                      char MenuStr3[] = "Baud Rate: `";
 223   2                      char MenuStr4[] = " 1200 2400 4800 9600`";
 224   2      
 225   2                      char MenuStr5[] = "Use parity bit?`";
 226   2                      char MenuStr7[] = "                    `";
 227   2      
 228   2                      char MenuStr10[]= "Start & stop bits?`";
 229   2                      char MenuStr11[]= " 1: Yes     2: No`";
 230   2      
 231   2                      char MenuStr14[]= "Enter 4 chars for TX`";
 232   2                      char MenuStr15[]= "Chars transmitted   `";
 233   2                      char MenuStr16[]= "# : Return to Main  `";
 234   2              
 235   2                      lcdClear();
 236   2                      lcdString( &MenuStr1 );
 237   2                      lcdLine(2);
 238   2                      lcdString( &MenuStr2 );
 239   2      
 240   2                      // stop bit prompt
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 5   

 241   2                      lcdLine(4);
 242   2                      lcdString( &MenuStr7 );
 243   2                      lcdLine(3);
 244   2                      lcdString( &MenuStr7 );
 245   2                      lcdLine(3);
 246   2                      lcdString( &MenuStr10 );
 247   2                      lcdLine(4);
 248   2                      lcdString( &MenuStr11 );
 249   2      
 250   2                      while(1) {      
 251   3                              keypad = getKeysPressed();
 252   3                      
 253   3                              if( keypad.k1 == true ) {
 254   4                                      waitForKeyRelease();
 255   4                                      stop_bits = true; 
 256   4                                      break;
 257   4                              }
 258   3                              else if( keypad.k2 == true ) {
 259   4                                      waitForKeyRelease();
 260   4                                      stop_bits = false;
 261   4                                      break;
 262   4                              }
 263   3                      } // end stop bit while
 264   2      
 265   2                      // parity prompt
 266   2                      if (stop_bits == true) {
 267   3                              lcdLine(3);
 268   3                              lcdString( &MenuStr7 );
 269   3                              lcdLine(3);
 270   3                              lcdString( &MenuStr5 );
 271   3              
 272   3                              while(1) {      
 273   4                                      keypad = getKeysPressed();
 274   4                              
 275   4                                      if( keypad.k1 == true ) {
 276   5                                              waitForKeyRelease();
 277   5                                              parity = true;
 278   5                                              break;
 279   5                                      }
 280   4                                      else if( keypad.k2 == true ) {
 281   5                                              waitForKeyRelease();
 282   5                                              parity = false;
 283   5                                              break;
 284   5                                      }
 285   4                              } // end parity while
 286   3                      } // end parity prompt
 287   2      
 288   2                      if (stop_bits == true) {
 289   3                              // baud prompt
 290   3                              while( (baud_rate != 0x1200) && (baud_rate != 0x2400) && (baud_rate != 0x4800) && (baud_rate != 0x9600)
             -) {
 291   4                                      lcdLine(4);
 292   4                                      lcdString( &MenuStr4 );
 293   4                                      lcdLine(3);
 294   4                                      lcdString( &MenuStr7 );
 295   4                                      lcdLine(3);
 296   4                                      lcdString( &MenuStr3 );
 297   4                                      baud_rate = input4Hex();
 298   4                              } // end baud rate input
 299   3                      } // end baud rate prompt
 300   2      
 301   2                      // characters prompt
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 6   

 302   2                      lcdClear();
 303   2                      lcdString( &MenuStr14 );
 304   2                      lcdLine(2);
 305   2                      tx_string = input4Hex();
 306   2      
 307   2                      // set transmit settings
 308   2                      TMOD = 0x20;    // Use Timer 1, 8-bit auto-reload
 309   2      
 310   2                      switch (baud_rate) {
 311   3                               case (0x1200): TH1 = 0xE6; break;
 312   3                               case (0x2400): TH1 = 0xF3; break;
 313   3                               case (0x4800): TH1 = 0xFA; break;
 314   3                               case (0x9600): TH1 = 0xFD; break;
 315   3                      } // end baud rate switch
 316   2      
 317   2                      if (stop_bits == false) {       // use mode 0
 318   3                              SCON = 0x10;
 319   3                      }
 320   2                      else if (parity == false) {     // use mode 1
 321   3                              SCON = 0x50;                    
 322   3                      }
 323   2                      else {                                          // use mode 3
 324   3                              SCON = 0xC0;    
 325   3                      }
 326   2      
 327   2                      // transmit
 328   2                      TR1 = 1;
 329   2                      ACC = (tx_string>>8) & 0xFF;
 330   2                      if (P) {        // set parity bit
 331   3                              SCON = SCON | 0x08;
 332   3                      }
 333   2                      SBUF = (tx_string>>8) & 0xFF;
 334   2                      while(TI==0);
 335   2                      TI = 0;
 336   2      
 337   2                      SCON = SCON &0xF7; // clear parity bit
 338   2                      ACC = tx_string & 0xFF;
 339   2                      if (P) {        // set parity bit
 340   3                              SCON = SCON | 0x08;
 341   3                      }
 342   2                      SBUF = tx_string & 0xFF;
 343   2                      while(TI==0);
 344   2                      TI = 0;
 345   2      
 346   2                      // transmit complete message
 347   2                      lcdLine(3);
 348   2                      lcdString( &MenuStr15 );
 349   2                      lcdLine(4);
 350   2                      lcdString( &MenuStr16 );
 351   2      
 352   2                      while(1) {      
 353   3                              keypad = getKeysPressed();
 354   3              
 355   3                              if( keypad.kpound == true ) {
 356   4                                      exit = true;
 357   4                                      waitForKeyRelease();
 358   4                                      break;
 359   4                              }
 360   3                      } // end option while
 361   2              } // end main while
 362   1      
 363   1      } // end seerialMenu()
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 7   

 364          // -------------------------------------------------------------- //
 365          
 366          void memoryMenu( void ) {
 367   1      
 368   1              struct keypad_data keypad;
 369   1              bool exit = false;
 370   1      
 371   1              while( exit == false ) {
 372   2      
 373   2                      char MenuStr1[] = "Memory Menu`";
 374   2                      char MenuStr2[] = "1 : Dump    2 : Move`";
 375   2                      char MenuStr3[] = "3 : Edit    4 : Find`";
 376   2                      char MenuStr4[] = "# : Return to Main  `";
 377   2              
 378   2                      lcdClear();
 379   2                      lcdString( &MenuStr1 );
 380   2                      lcdLine(2);
 381   2                      lcdString( &MenuStr2 );
 382   2                      lcdLine(3);
 383   2                      lcdString( &MenuStr3 );
 384   2                      lcdLine(4);
 385   2                      lcdString( &MenuStr4 );
 386   2              
 387   2                      while(1) {      
 388   3                              keypad = getKeysPressed();
 389   3                      
 390   3                              if( keypad.kpound == true ) {
 391   4                                      exit = true;
 392   4                                      waitForKeyRelease();
 393   4                                      break;
 394   4                              }
 395   3                              else if( keypad.k1 == true ) {
 396   4                                      waitForKeyRelease();
 397   4                                      dumpMenu();
 398   4                                      break;
 399   4                              }
 400   3                              else if( keypad.k2 == true ) {
 401   4                                      waitForKeyRelease();
 402   4                                      moveMenu();
 403   4                                      break;
 404   4                              }
 405   3                              else if( keypad.k3 == true ) {
 406   4                                      waitForKeyRelease();
 407   4                                      editMenu();
 408   4                                      break;
 409   4                              }
 410   3                              else if( keypad.k4 == true ) {
 411   4                                      waitForKeyRelease();
 412   4                                      findMenu();
 413   4                                      break;
 414   4                              }
 415   3                      } // end option while
 416   2      
 417   2              } // end main while
 418   1      
 419   1      } // end memoryMenu()
 420          // -------------------------------------------------------------- //
 421          
 422          void dumpMenu( void ) {
 423   1      
 424   1              struct keypad_data keypad;
 425   1              bool exit;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 8   

 426   1              word segment;
 427   1              word block;
 428   1              word offset;
 429   1              byte memVal;
 430   1              int i;
 431   1              
 432   1              char MenuStr1[] = "Dump Setup`";
 433   1              char MenuStr2[] = "Start Seg Addr: `";
 434   1              char MenuStr3[] = "Block Size: `";
 435   1              char MenuStr4[] = "1:<--  2:-->  #:Exit`";
 436   1      
 437   1              exit = false;
 438   1              segment = 0x0000;
 439   1              block = 0x0000;
 440   1              offset = 0x0000;
 441   1      
 442   1              //----------------//
 443   1              //   Dump Setup   //
 444   1              //----------------//
 445   1      
 446   1              // print header and footer
 447   1              lcdClear();
 448   1              lcdString( &MenuStr1 );
 449   1      
 450   1              // address prompt
 451   1              lcdLine(3);
 452   1              lcdString( &MenuStr2 );
 453   1              // read 4 hex digits from keypad
 454   1              segment = input4Hex(); 
 455   1      
 456   1              // block size prompt
 457   1              lcdLine(4);
 458   1              lcdString( &MenuStr3 );
 459   1              // read 4 hex digits from keypad
 460   1              while( block == 0x0000 ) {
 461   2                      block = input4Hex();
 462   2              }
 463   1      
 464   1              //------------------//
 465   1              //   Dump Display   //
 466   1              //------------------//
 467   1      
 468   1              while( exit == false ) {
 469   2      
 470   2                      // print segment:offset
 471   2                      lcdClear();
 472   2                      lcdHexWord( segment );
 473   2                      lcdChar(':');
 474   2                      lcdHexWord( offset );
 475   2      
 476   2                      // print hex values
 477   2                      lcdLine(2);
 478   2                      for( i = 0; i < 7; i++ ) {
 479   3                              if( (offset + i) < block ) {
 480   4                                      memVal = XBYTE[ (segment * 16) + offset + i ]; // get seg:offset+i
 481   4                                      lcdHexByte( memVal );   // print value
 482   4                                      if( i < 6 ) {
 483   5                                              lcdChar(' ');           // print space if not last one on line
 484   5                                      }
 485   4                              }
 486   3                      }
 487   2      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 9   

 488   2                      // print ascii values
 489   2                      lcdLine(3);
 490   2                      for( i = 0; i < 7; i++ ) {
 491   3                              if( (offset + i) < block ) {
 492   4                                      memVal = XBYTE[ (segment * 16) + offset + i ]; // get seg:offset+i
 493   4                                      lcdAsciiByte( memVal ); // print value
 494   4                                      lcdChar(' ');
 495   4                                      if( i < 6 ) {
 496   5                                              lcdChar(' ');           // print space if not last one on line
 497   5                                      }
 498   4                              }
 499   3                      }
 500   2      
 501   2                      // print footer
 502   2                      lcdLine(4);
 503   2                      lcdString( &MenuStr4 );         
 504   2                              
 505   2                      while(1) {      
 506   3                              keypad = getKeysPressed();
 507   3                      
 508   3                              if( keypad.kpound == true ) {
 509   4                                      exit = true;
 510   4                                      waitForKeyRelease();
 511   4                                      break;
 512   4                              }
 513   3                              else if( keypad.k1 == true ) {
 514   4                                      waitForKeyRelease();
 515   4                                      // if decremented offset is less than start (0),
 516   4                                      if( offset >= 7 ) {
 517   5                                              //      revert (-7) and do nothing
 518   5                                              offset -= 7;
 519   5                                      }
 520   4                                      break;
 521   4                              }
 522   3                              else if( keypad.k2 == true ) {
 523   4                                      waitForKeyRelease();
 524   4                                      // increment offset by 7
 525   4                                      offset += 7;
 526   4                                      // if incremented offset is past block size,
 527   4                                      if( offset > block ) {
 528   5                                              //      revert (-7) and do nothing
 529   5                                              offset -= 7;
 530   5                                      }
 531   4                                      break;
 532   4                              }
 533   3                      } // end option while
 534   2      
 535   2              } // end main while
 536   1      
 537   1      } // end dumpMenu()
 538          
 539          // -------------------------------------------------------------- //
 540          
 541          void moveMenu( void ) {
 542   1      
 543   1              struct keypad_data keypad;
 544   1              bool exit;
 545   1              word sourceSegment;
 546   1              word destSegment;
 547   1              word block;
 548   1              word offset;
 549   1              byte memVal;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 10  

 550   1              int i;
 551   1              
 552   1              char MenuStr1[] = "Move Setup`";
 553   1              char MenuStr2[] = "Source Seg Addr: `";
 554   1              char MenuStr3[] = "Dest Seg Addr: `";
 555   1              char MenuStr4[] = "Block Size: `";
 556   1              char MenuStr5[] = "Move Complete`";
 557   1              char MenuStr6[] = "#:Exit`";
 558   1      
 559   1              exit = false;
 560   1              sourceSegment = 0x0000;
 561   1              destSegment = 0x0000;
 562   1              block = 0x0000;
 563   1              offset = 0x0000;
 564   1              i = 0;
 565   1      
 566   1              //----------------//
 567   1              //   Move Setup   //
 568   1              //----------------//
 569   1      
 570   1              // print header and footer
 571   1              lcdClear();
 572   1              lcdString( &MenuStr1 );
 573   1      
 574   1              // source address prompt
 575   1              lcdLine(2);
 576   1              lcdString( &MenuStr2 );
 577   1              // read 4 hex digits from keypad
 578   1              sourceSegment = input4Hex(); 
 579   1      
 580   1              // dest address prompt
 581   1              lcdLine(3);
 582   1              lcdString( &MenuStr3 );
 583   1              // read 4 hex digits from keypad
 584   1              destSegment = input4Hex();
 585   1      
 586   1              // block size prompt
 587   1              lcdLine(4);
 588   1              lcdString( &MenuStr4 );
 589   1              // read 4 hex digits from keypad
 590   1              while( block == 0x0000 ) {
 591   2                      block = input4Hex();
 592   2              }
 593   1      
 594   1              //------------------//
 595   1              //   Move Display   //
 596   1              //------------------//
 597   1      
 598   1              while( exit == false ) {
 599   2      
 600   2                      // print segment:offset
 601   2                      lcdClear();
 602   2                      lcdString( &MenuStr5 );
 603   2                      lcdLine(4);
 604   2                      lcdString( &MenuStr6 );
 605   2      //              lcdHexWord( segment );
 606   2      //              lcdChar(':');
 607   2      //              lcdHexWord( offset );
 608   2                      
 609   2      
 610   2                      // perform move
 611   2                      while( (offset + i) < block ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 11  

 612   3                              memVal = XBYTE[ (sourceSegment * 16) + offset + i ]; // get sourceSeg:offset+i
 613   3                              XBYTE[ (destSegment * 16) + offset + i ] = memVal;      // move to destSeg:offset+i
 614   3                              i++;
 615   3                      }       
 616   2                              
 617   2                      while(1) {      
 618   3                              keypad = getKeysPressed();
 619   3                      
 620   3                              if( keypad.kpound == true ) {
 621   4                                      exit = true;
 622   4                                      waitForKeyRelease();
 623   4                                      break;
 624   4                              }
 625   3      
 626   3                      } // end option while
 627   2      
 628   2              } // end main while
 629   1      
 630   1      } // end moveMenu()
 631          
 632          // -------------------------------------------------------------- //
 633          
 634          void editMenu( void ) {
 635   1      
 636   1              struct keypad_data keypad;
 637   1              bool exit;
 638   1              bool next;
 639   1              word segment;
 640   1              word offset;
 641   1              byte new_value;
 642   1              byte memVal;
 643   1              
 644   1              char MenuStr1[] = "Edit Setup`";
 645   1              char MenuStr2[] = "Segment Addr: `";
 646   1              char MenuStr3[] = "Offset Addr: `";
 647   1              char MenuStr4[] = "New Value: `";
 648   1              char MenuStr5[] = "Edit Complete`";
 649   1              char MenuStr6[] = "0:Continue    #:Exit`";
 650   1      
 651   1              exit = false;
 652   1              next = true;
 653   1              segment = 0x0000;
 654   1              offset = 0x0000;
 655   1              new_value = 0xAA;
 656   1      
 657   1              //----------------//
 658   1              //   Edit Setup   //
 659   1              //----------------//
 660   1      
 661   1              // print header and footer
 662   1              lcdClear();
 663   1              lcdString( &MenuStr1 );
 664   1      
 665   1              // segment address prompt
 666   1              lcdLine(2);
 667   1              lcdString( &MenuStr2 );
 668   1              // read 4 hex digits from keypad
 669   1              segment = input4Hex(); 
 670   1      
 671   1              // offset address prompt
 672   1              lcdLine(3);
 673   1              lcdString( &MenuStr3 );
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 12  

 674   1              // read 4 hex digits from keypad
 675   1              offset = input4Hex();
 676   1              
 677   1              //------------------//
 678   1              //   Edit Display   //
 679   1              //------------------//
 680   1      
 681   1              while( exit == false ) {
 682   2      
 683   2                      if( next == true ) {
 684   3      
 685   3                              // print segment:offset
 686   3                              lcdClear();
 687   3                              lcdHexWord( segment );
 688   3                              lcdChar(':');
 689   3                              lcdHexWord( offset );
 690   3                              lcdChar(' ');
 691   3      
 692   3                              // print current value
 693   3                              memVal = XBYTE[ (segment * 16) + offset ]; // get seg:offset
 694   3                              lcdHexByte( memVal );   // print value
 695   3                      
 696   3                              // new value prompt
 697   3                              lcdLine(2);
 698   3                              lcdString( &MenuStr4 );
 699   3                      
 700   3                              // read 2 hex digits from keypad
 701   3                              new_value = input2Hex();
 702   3                              // store value
 703   3                              XBYTE[ (segment * 16) + offset ] = new_value;   // move to destSeg:offset
 704   3                      
 705   3                              // edit complete
 706   3                              lcdLine(3);
 707   3                              lcdString( &MenuStr5 );
 708   3                      
 709   3                              // exit prompt
 710   3                              lcdLine(4);
 711   3                              lcdString( &MenuStr6 );
 712   3      
 713   3                              offset++;
 714   3      
 715   3                      } // end next if
 716   2                              
 717   2                      while(1) {      
 718   3      
 719   3                              keypad = getKeysPressed();
 720   3                      
 721   3                              if( keypad.kpound == true ) {
 722   4                                      next = false;
 723   4                                      exit = true;
 724   4                                      waitForKeyRelease();
 725   4                                      break;
 726   4                              }
 727   3      
 728   3                              if( keypad.k0 == true ) {
 729   4                                      next = true;
 730   4                                      waitForKeyRelease();
 731   4                                      break;
 732   4                              }
 733   3      
 734   3                      } // end option while
 735   2      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 13  

 736   2              } // end main while
 737   1      
 738   1      } // end editMenu()
 739          
 740          // -------------------------------------------------------------- //
 741          
 742          void findMenu( void ) {
 743   1      
 744   1              struct keypad_data keypad;
 745   1              bool exit;
 746   1              bool found;
 747   1              word segment;
 748   1              word offset;
 749   1              word block;
 750   1              byte search_value;
 751   1              byte memVal;
 752   1              
 753   1              char MenuStr1[] = "Find Setup`";
 754   1              char MenuStr2[] = "Start Seg Addr: `";
 755   1              char MenuStr3[] = "Block Size: `";
 756   1              char MenuStr4[] = "Search Value: `";
 757   1              char MenuStr5[] = "Value found at`";
 758   1              char MenuStr6[] = "Value not found!`";
 759   1              char MenuStr7[] = "#:Exit`";
 760   1      
 761   1              exit = false;
 762   1              found = false;
 763   1              segment = 0x0000;
 764   1              offset = 0x0000;
 765   1              block = 0x0000;
 766   1              search_value = 0xAA;
 767   1      
 768   1              //----------------//
 769   1              //   Find Setup   //
 770   1              //----------------//
 771   1      
 772   1              // print header and footer
 773   1              lcdClear();
 774   1              lcdString( &MenuStr1 );
 775   1      
 776   1              // start address prompt
 777   1              lcdLine(2);
 778   1              lcdString( &MenuStr2 );
 779   1              // read 4 hex digits from keypad
 780   1              segment = input4Hex(); 
 781   1      
 782   1              // block size prompt
 783   1              lcdLine(3);
 784   1              lcdString( &MenuStr3 );
 785   1              // read 4 hex digits from keypad
 786   1              block = input4Hex();
 787   1      
 788   1              // search value prompt
 789   1              lcdLine(4);
 790   1              lcdString( &MenuStr4 );
 791   1              // read 4 hex digits from keypad
 792   1              search_value = input2Hex();
 793   1              
 794   1              //------------------//
 795   1              //   Find Display   //
 796   1              //------------------//
 797   1      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 14  

 798   1              // search block for value
 799   1              while( (offset) < block ) {
 800   2                      memVal = XBYTE[ (segment * 16) + offset ]; // get seg:offset+i
 801   2                      if( memVal == search_value ) {
 802   3                         found = true;
 803   3                         break;
 804   3                      }
 805   2                      offset++;
 806   2              }
 807   1      
 808   1              // print result
 809   1              lcdClear();
 810   1              if( found == true ) {
 811   2                      // Value found at ...
 812   2                      lcdString( &MenuStr5 );
 813   2                      // print segment:offset
 814   2                      lcdLine(2);
 815   2                      lcdHexWord( segment );
 816   2                      lcdChar(':');
 817   2                      lcdHexWord( offset );
 818   2                      // Footer
 819   2                      lcdLine(4);
 820   2                      lcdString( &MenuStr7 );
 821   2              }
 822   1              else {
 823   2                      // Value not found
 824   2                      lcdString( &MenuStr6 );
 825   2                      // Footer
 826   2                      lcdLine(4);
 827   2                      lcdString( &MenuStr7 );
 828   2              }
 829   1      
 830   1              while( exit == false ) {
 831   2                              
 832   2                      while(1) {      
 833   3      
 834   3                              keypad = getKeysPressed();
 835   3                      
 836   3                              if( keypad.kpound == true ) {
 837   4                                      exit = true;
 838   4                                      waitForKeyRelease();
 839   4                                      break;
 840   4                              }
 841   3      
 842   3                      } // end option while
 843   2      
 844   2              } // end main while
 845   1      
 846   1      } // end findMenu()
 847          
 848          // -------------------------------------------------------------- //
 849          
 850          word input4Hex( void ) {
 851   1      
 852   1              word segment;
 853   1              word input;
 854   1              int i;
 855   1              
 856   1              segment = 0x0000;
 857   1      
 858   1              for( i = 0; i < 4; i++ ) {
 859   2                      segment = segment << 4;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 15  

 860   2                      input = inputHex();
 861   2                      segment = segment + input;
 862   2              }
 863   1         
 864   1              return segment;
 865   1      
 866   1      } // end input4Hex()
 867          
 868          // -------------------------------------------------------------- //
 869          
 870          byte input2Hex( void ) {
 871   1      
 872   1              byte value;
 873   1              word input;
 874   1              int i;
 875   1              
 876   1              value = 0x00;
 877   1      
 878   1              for( i = 0; i < 2; i++ ) {
 879   2                      value = value << 4;
 880   2                      input = inputHex();
 881   2                      value = value + input;
 882   2              }
 883   1         
 884   1              return value;
 885   1      
 886   1      } // end input2Hex()
 887          
 888          // -------------------------------------------------------------- //
 889          
 890          word inputHex( void ) {
 891   1      
 892   1              struct keypad_data keypad;
 893   1              word value;
 894   1              byte ascii;
 895   1              
 896   1              
 897   1              value = 0xFFFF;
 898   1              ascii = 0x7E;
 899   1              
 900   1              while( value == 0xFFFF ) {
 901   2                
 902   2                      keypad = getKeysPressed();
 903   2      
 904   2                      if( keypad.k0 == true ) {
 905   3                              value = 0x0000;
 906   3                              ascii = 0x30;
 907   3                      }
 908   2                      if( keypad.k1 == true ) {
 909   3                              value = 0x0001;
 910   3                              ascii = 0x31;
 911   3                      }
 912   2                      if( keypad.k2 == true ) {
 913   3                              value = 0x0002;
 914   3                              ascii = 0x32;
 915   3                      }
 916   2                      if( keypad.k3 == true ) {
 917   3                              value = 0x0003;
 918   3                              ascii = 0x33;
 919   3                      }
 920   2                      if( keypad.k4 == true ) {
 921   3                              value = 0x0004;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 16  

 922   3                              ascii = 0x34;
 923   3                      }
 924   2                      if( keypad.k5 == true ) {
 925   3                              value = 0x0005;
 926   3                              ascii = 0x35;
 927   3                      }
 928   2                      if( keypad.k6 == true ) {
 929   3                              value = 0x0006;
 930   3                              ascii = 0x36;
 931   3                      }
 932   2                      if( keypad.k7 == true ) {
 933   3                              value = 0x0007;
 934   3                              ascii = 0x37;
 935   3                      }
 936   2                      if( keypad.k8 == true ) {
 937   3                              value = 0x0008;
 938   3                              ascii = 0x38;
 939   3                      }
 940   2                      if( keypad.k9 == true ) {
 941   3                              value = 0x0009;
 942   3                              ascii = 0x39;
 943   3                      }
 944   2                      if( keypad.kA == true ) {
 945   3                              value = 0x000A;
 946   3                              ascii = 0x41;
 947   3                      }
 948   2                      if( keypad.kB == true ) {
 949   3                              value = 0x000B;
 950   3                              ascii = 0x42;
 951   3                      }
 952   2                      if( keypad.kC == true ) {
 953   3                              value = 0x000C;
 954   3                              ascii = 0x43;
 955   3                      }
 956   2                      if( keypad.kD == true ) {
 957   3                              value = 0x000D;
 958   3                              ascii = 0x44;
 959   3                      }
 960   2                      if( keypad.kstar == true ) {
 961   3                              value = 0x000E;
 962   3                              ascii = 0x45;
 963   3                      }
 964   2                      if( keypad.kpound == true ) {
 965   3                              value = 0x000F;
 966   3                              ascii = 0x46;
 967   3                      }
 968   2      
 969   2              } // end while
 970   1      
 971   1              lcdChar( ascii );
 972   1      
 973   1              waitForKeyRelease();
 974   1              return value;   
 975   1      
 976   1      } // end readHex()
 977          
 978          // -------------------------------------------------------------- //
 979          
 980          void waitForKeyRelease( void ) {
 981   1      
 982   1              struct keypad_data keypad;
 983   1              bool exit = false;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 17  

 984   1              
 985   1              while( exit == false ) {
 986   2      
 987   2                      exit = true;
 988   2                      keypad = getKeysPressed();
 989   2      
 990   2                      if( keypad.k0 == true ) {
 991   3                              exit = false;
 992   3                      }
 993   2                      if( keypad.k1 == true ) {
 994   3                              exit = false;
 995   3                      }
 996   2                      if( keypad.k2 == true ) {
 997   3                              exit = false;
 998   3                      }
 999   2                      if( keypad.k3 == true ) {
1000   3                              exit = false;
1001   3                      }
1002   2                      if( keypad.k4 == true ) {
1003   3                              exit = false;
1004   3                      }
1005   2                      if( keypad.k5 == true ) {
1006   3                              exit = false;
1007   3                      }
1008   2                      if( keypad.k6 == true ) {
1009   3                              exit = false;
1010   3                      }
1011   2                      if( keypad.k7 == true ) {
1012   3                              exit = false;
1013   3                      }
1014   2                      if( keypad.k8 == true ) {
1015   3                              exit = false;
1016   3                      }
1017   2                      if( keypad.k9 == true ) {
1018   3                              exit = false;
1019   3                      }
1020   2                      if( keypad.kA == true ) {
1021   3                              exit = false;
1022   3                      }
1023   2                      if( keypad.kB == true ) {
1024   3                              exit = false;
1025   3                      }
1026   2                      if( keypad.kC == true ) {
1027   3                              exit = false;
1028   3                      }
1029   2                      if( keypad.kD == true ) {
1030   3                              exit = false;
1031   3                      }
1032   2                      if( keypad.kstar == true ) {
1033   3                              exit = false;
1034   3                      }
1035   2                      if( keypad.kpound == true ) {
1036   3                              exit = false;
1037   3                      }
1038   2      
1039   2              } // end while
1040   1              
1041   1              msDelay(100);     
1042   1      
1043   1      } // end waitForKeyRelease()
1044          
1045          // -------------------------------------------------------------- //
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 18  

1046          
1047          void latchKeypad( void ) {
1048   1              
1049   1      //      cs_keypad = 1;
1050   1      //      cs_keypad = 0;
1051   1              
1052   1              missionControl1( ctrl_kp_oelatch );
1053   1              missionControl1( ctrl_kp_oe );
1054   1              
1055   1      } // end latchKeypad()
1056          
1057          
1058          // -------------------------------------------------------------- //
1059          
1060          struct keypad_data getKeysPressed( void ) {
1061   1              
1062   1              struct keypad_data keypad;
1063   1              
1064   1              // enable keypad latch output
1065   1              //oe_keypad = 0;
1066   1              missionControl1( ctrl_kp_oe );
1067   1              
1068   1              // Set keypad columns as outputs & rows as inputs
1069   1              kCol1 = 0;
1070   1              kCol2 = 0;
1071   1              kCol3 = 0;
1072   1              kCol4 = 0;
1073   1              kRow1 = 1;
1074   1              kRow2 = 1;
1075   1              kRow3 = 1;
1076   1              kRow4 = 1;
1077   1              
1078   1              // scan by columns
1079   1      
1080   1              // column 1
1081   1              kCol1 = 0;
1082   1              kCol2 = 1;
1083   1              kCol3 = 1;
1084   1              kCol4 = 1;
1085   1              latchKeypad();
1086   1              
1087   1              if (kRow1 == 0) {
1088   2                      keypad.k1 = 1;
1089   2              }
1090   1              else {
1091   2                      keypad.k1 = 0;
1092   2              }
1093   1              if (kRow2 == 0) {
1094   2                      keypad.k4 = 1;
1095   2              }
1096   1              else {
1097   2                      keypad.k4 = 0;
1098   2              }
1099   1              if (kRow3 == 0) {
1100   2                      keypad.k7 = 1;
1101   2              }
1102   1              else {
1103   2                      keypad.k7 = 0;
1104   2              }
1105   1              if (kRow4 == 0) {
1106   2                      keypad.kstar = 1;
1107   2              }
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 19  

1108   1              else {
1109   2                      keypad.kstar = 0;
1110   2              }
1111   1              kCol1 = 1;
1112   1              
1113   1              // column 2
1114   1              kCol2 = 0;
1115   1              latchKeypad();
1116   1              
1117   1              if (kRow1 == 0) {
1118   2                      keypad.k2 = 1;
1119   2              }
1120   1              else {
1121   2                      keypad.k2 = 0;
1122   2              }
1123   1              if (kRow2 == 0) {
1124   2                      keypad.k5 = 1;
1125   2              }
1126   1              else {
1127   2                      keypad.k5 = 0;
1128   2              }
1129   1              if (kRow3 == 0) {
1130   2                      keypad.k8 = 1;
1131   2              }
1132   1              else {
1133   2                      keypad.k8 = 0;
1134   2              }
1135   1              if (kRow4 == 0) {
1136   2                      keypad.k0 = 1;
1137   2              }
1138   1              else {
1139   2                      keypad.k0 = 0;
1140   2              }
1141   1              kCol2 = 1;
1142   1              
1143   1              // column 3
1144   1              kCol3 = 0;
1145   1              latchKeypad();
1146   1              
1147   1              if (kRow1 == 0) {
1148   2                      keypad.k3 = 1;
1149   2              }
1150   1              else {
1151   2                      keypad.k3 = 0;
1152   2              }
1153   1              if (kRow2 == 0) {
1154   2                      keypad.k6 = 1;
1155   2              }
1156   1              else {
1157   2                      keypad.k6 = 0;
1158   2              }
1159   1              if (kRow3 == 0) {
1160   2                      keypad.k9 = 1;
1161   2              }
1162   1              else {
1163   2                      keypad.k9 = 0;
1164   2              }
1165   1              if (kRow4 == 0) {
1166   2                      keypad.kpound = 1;
1167   2              }
1168   1              else {
1169   2                      keypad.kpound = 0;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 20  

1170   2              }
1171   1              kCol3 = 1;
1172   1              
1173   1              // column 4
1174   1              kCol4 = 0;
1175   1              latchKeypad();
1176   1              
1177   1              if (kRow1 == 0) {
1178   2                      keypad.kA = 1;
1179   2              }
1180   1              else {
1181   2                      keypad.kA = 0;
1182   2              }
1183   1              if (kRow2 == 0) {
1184   2                      keypad.kB = 1;
1185   2              }
1186   1              else {
1187   2                      keypad.kB = 0;
1188   2              }
1189   1              if (kRow3 == 0) {
1190   2                      keypad.kC = 1;
1191   2              }
1192   1              else {
1193   2                      keypad.kC = 0;
1194   2              }
1195   1              if (kRow4 == 0) {
1196   2                      keypad.kD = 1;
1197   2              }
1198   1              else {
1199   2                      keypad.kD = 0;
1200   2              }
1201   1              kCol4 = 1;
1202   1              latchKeypad();
1203   1              
1204   1              // disable keypad latch output
1205   1              //oe_keypad = 1;
1206   1              missionControl1( ctrl_off );
1207   1              
1208   1              return keypad; 
1209   1              
1210   1      } // end getKeysPressed()
1211          
1212          // -------------------------------------------------------------- //
1213          
1214          void lcdCmd( byte cmd ) {
1215   1              
1216   1              //rs_lcd = 0;                   // reg select low for command
1217   1              // --- RW tied low for write --- //
1218   1              //e_lcd = 1;                    // E high for pulse
1219   1              
1220   1              missionControl1( ctrl_lcd_cmd_start );
1221   1              
1222   1              lcdPort = cmd;
1223   1              //latchLCD();
1224   1              
1225   1              msDelay(1);                     // Need Tpw > 140 ns
1226   1              //e_lcd = 0;                    // E low to end pulse
1227   1              
1228   1              missionControl1( ctrl_lcd_cmd_finish );
1229   1              
1230   1      } // end lcdCmd()
1231          
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 21  

1232          // -------------------------------------------------------------- //
1233          
1234          void lcdData( byte dat ) {
1235   1              
1236   1              //rs_lcd = 1;                   // reg select high for data
1237   1              // --- RW tied low for write --- //
1238   1              //e_lcd = 1;                    // E high for pulse
1239   1              
1240   1              missionControl1( ctrl_lcd_data_start );
1241   1              
1242   1              lcdPort = dat;
1243   1              //latchLCD();
1244   1              
1245   1              msDelay(1);                     // Need Tpw > 140 ns
1246   1              //e_lcd = 0;                    // E low to end pulse
1247   1              
1248   1              missionControl1( ctrl_lcd_data_finish );
1249   1              
1250   1      } // end lcdData()
1251          
1252          // -------------------------------------------------------------- //
1253          
1254          void lcdInit( void ) {  
1255   1              
1256   1              msDelay(50);
1257   1              lcdCmd(0x38);                   // Function set
1258   1              msDelay(5);
1259   1              lcdCmd(0x38);                   // Function set
1260   1              msDelay(1);
1261   1              lcdCmd(0x0F);                   // Display ON/OFF control
1262   1              msDelay(1);
1263   1              lcdCmd(0x01);                   // Clear display
1264   1              msDelay(2);
1265   1              
1266   1      } // end lcdInit()
1267          
1268          // -------------------------------------------------------------- //
1269          
1270          void lcdClear( void ) {
1271   1              
1272   1              lcdCmd(0x01);                   // Clear display
1273   1              msDelay(2);
1274   1              
1275   1      } // end lcdClear()
1276          
1277          // -------------------------------------------------------------- //
1278          
1279          void lcdChar( byte character ) {
1280   1              
1281   1              lcdData(character);             // send character
1282   1              
1283   1      } // end lcdChar()
1284          
1285          // -------------------------------------------------------------- //
1286          
1287          void lcdString( volatile char *string ) {
1288   1              
1289   1              int i = 0;
1290   1              while( string[i] != '`') {
1291   2                      lcdChar( string[i] );
1292   2                      i++;
1293   2              }
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 22  

1294   1              
1295   1      } // end lcdString()
1296          
1297          // -------------------------------------------------------------- //
1298          
1299          void lcdLine( int line ) {
1300   1              
1301   1              switch (line) {
1302   2                      case 1: {
1303   3                              lcdCmd(0x80);
1304   3                              break;
1305   3                      }
1306   2                      case 2: {
1307   3                              lcdCmd(0xC0);
1308   3                              break;
1309   3                      }
1310   2                      case 3: {
1311   3                              lcdCmd(0x94);
1312   3                              break;
1313   3                      }
1314   2                      case 4: {
1315   3                              lcdCmd(0xD4);
1316   3                              break;
1317   3                      }
1318   2                      default:
1319   2                              lcdCmd(0x80);
1320   2                      
1321   2              } // end switch
1322   1              
1323   1      } // end lcdLine()
1324          
1325          // -------------------------------------------------------------- //
1326          
1327          void lcdHexWord( word hex ) {
1328   1      
1329   1              char hexStr[] = "--------`";
1330   1      
1331   1              sprintf( hexStr, "%04X`", (int)hex );
1332   1              lcdString( &hexStr );
1333   1      
1334   1      } // end lcdHexWord()
1335          
1336          // -------------------------------------------------------------- //
1337          
1338          void lcdHexByte( byte hex ) {
1339   1      
1340   1              char hexStr[] = "-----`";
1341   1      
1342   1              sprintf( hexStr, "%02X`", (int)hex );
1343   1              lcdString( &hexStr );
1344   1      
1345   1      } // end lcdHexWord()
1346          
1347          // -------------------------------------------------------------- //
1348          
1349          void lcdAsciiByte( byte hex ) {
1350   1      
1351   1      //      char hexStr[] = "-----`";
1352   1      //
1353   1      //      sprintf( hexStr, "%1c`", (int)hex );
1354   1      //      lcdString( &hexStr );
1355   1      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 23  

1356   1              lcdChar( hex );
1357   1      
1358   1      } // end lcdHexWord()
1359          
1360          // -------------------------------------------------------------- //
1361          
1362          void missionControl1( int dec ) {
1363   1              
1364   1              switch ( dec ) {
1365   2                      
1366   2                      // The MSB is changed first to avoid false triggers of the LCD enable
1367   2                      // line as the enable line never goes high when the MSB is low.
1368   2                      case ctrl_off: {
1369   3                              dec2 = 0;
1370   3                              dec1 = 0;
1371   3                              dec0 = 0;
1372   3                              break;
1373   3                      }
1374   2                      case ctrl_ss_latch: {
1375   3                              dec2 = 0;
1376   3                              dec1 = 0;
1377   3                              dec0 = 1;
1378   3                              break;
1379   3                      }
1380   2                      case ctrl_kp_oe: {
1381   3                              dec2 = 0;
1382   3                              dec1 = 1;
1383   3                              dec0 = 0;
1384   3                              break;
1385   3                      }
1386   2                      case ctrl_kp_oelatch: {
1387   3                              dec2 = 0;
1388   3                              dec1 = 1;
1389   3                              dec0 = 1;
1390   3                              break;
1391   3                      }
1392   2                      case ctrl_lcd_cmd_start: {
1393   3                              dec2 = 1;
1394   3                              dec1 = 0;
1395   3                              dec0 = 0;
1396   3                              break;
1397   3                      }
1398   2                      case ctrl_lcd_cmd_finish: {
1399   3                              dec2 = 1;
1400   3                              dec1 = 0;
1401   3                              dec0 = 1;
1402   3                              break;
1403   3                      }
1404   2                      case ctrl_lcd_data_start: {
1405   3                              dec2 = 1;
1406   3                              dec1 = 1;
1407   3                              dec0 = 0;
1408   3                              break;
1409   3                      }
1410   2                      case ctrl_lcd_data_finish: {
1411   3                              dec2 = 1;
1412   3                              dec1 = 1;
1413   3                              dec0 = 1;
1414   3                              break;
1415   3                      }               
1416   2              } // end switch
1417   1              
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     10/03/2017 23:24:30 PAGE 24  

1418   1      } // end missionControl1()
1419          
1420          // -------------------------------------------------------------- //
1421          
1422          void msDelay( unsigned msecs ) {
1423   1              
1424   1              unsigned i;
1425   1              unsigned char j;
1426   1              
1427   1              msecs = msecs * 3.23;
1428   1              
1429   1              for(i=0;i<msecs;i++){
1430   2                      for(j=0;j<100;j++);
1431   2              }
1432   1              
1433   1      } // end msDelay()
1434          
1435          // -------------------------------------------------------------- //
1436          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4714    ----
   CONSTANT SIZE    =    746    ----
   XDATA SIZE       =   ----     961
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
